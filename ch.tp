{**********************************************************************}
{*                                                                    *}
{*           L      U   U   DDDD   W      W  IIIII   GGGG             *}
{*           L      U   U   D   D   W    W     I    G                 *}
{*           L      U   U   D   D   W ww W     I    G   GG            *}
{*           L      U   U   D   D    W  W      I    G    G            *}
{*           LLLLL   UUU    DDDD     W  W    IIIII   GGGG             *}
{*                                                                    *}
{**********************************************************************}
{*                                                                    *}
{*  Copyright (C) 1981, 1987                                          *}
{*  Department of Computer Science, University of Adelaide, Australia *}
{*  All rights reserved.                                              *}
{*  Reproduction of the work or any substantial part thereof in any   *}
{*  material form whatsoever is prohibited.                           *}
{*                                                                    *}
{**********************************************************************}

{++
! Name:         CH
!
! Description:  These are basic character manipulation routines that are
!               not normally available in Pascal. Turbo Pascal provides
!               them in it's runtime libraries.
!
! Revision History:
!--}

{#if turbop}
unit ch;

interface
uses value, msdos;
{$I ch.h}

implementation

{--------------------------------------------------------------------}

procedure ch_move {(
	var     src ;
		st1 : strlen_range;
	var     dst ;
		st2 : strlen_range;
		len : strlen_range)};

begin
move(str_object(src)[st1], str_object(dst)[st2], len);
end;

{--------------------------------------------------------------------}

procedure ch_copy {(
	var     src     ;
		st1     : strlen_range;
		src_len : strlen_range;
	var     dst     ;
		st2     : strlen_range;
		dst_len : strlen_range;
		fill    : char)};

var
d,
len : strlen_range;
begin
len := min(src_len, dst_len);
if len <> 0 then
  move(str_object(src)[st1], str_object(dst)[st2], len);
d := st2 + len;
len := dst_len - src_len;
if len > 0 then
  fillchar(str_object(dst)[d],len,fill);
end;

procedure ch_copy_str_name {(
	var     src     ;
		st1     : strlen_range;
		src_len : strlen_range;
	var     dst     ;
		st2     : strlen_range;
		dst_len : strlen_range;
		fill    : char)};

var
d,
len : strlen_range;
begin
len := min(src_len, dst_len);
if len <> 0 then
  move(str_object(src)[st1], str_object(dst)[st2], len);
d := st2 + len;
len := dst_len - src_len;
if len > 0 then
  fillchar(str_object(dst)[d],len,fill);
end; {ch_copy_str_name}

procedure ch_copy_name_str {(
	var     src     ;
		st1     : strlen_range;
		src_len : strlen_range;
	var     dst     ;
		st2     : strlen_range;
		dst_len : strlen_range;
		fill    : char)};

var
d,
len : strlen_range;
begin
len := min(src_len, dst_len);
if len <> 0 then
  move(str_object(src)[st1], str_object(dst)[st2], len);
d := st2 + len;
len := dst_len - src_len;
if len > 0 then
  fillchar(str_object(dst)[d],len,fill);
end; {ch_copy_name_str}

procedure ch_copy_str_fnm {(
	var     src     ;
		st1     : strlen_range;
		src_len : strlen_range;
	var     dst     ;
		st2     : strlen_range;
		dst_len : strlen_range;
		fill    : char)};

var
d,
len : strlen_range;
begin
len := min(src_len, dst_len);
if len <> 0 then
  move(str_object(src)[st1], str_object(dst)[st2], len);
d := st2 + len;
len := dst_len - src_len;
if len > 0 then
  fillchar(str_object(dst)[d],len,fill);
end; {ch_copy_str_fnm}

procedure ch_copy_fnm_str {(
	var     src     ;
		st1     : strlen_range;
		src_len : strlen_range;
	var     dst     ;
		st2     : strlen_range;
		dst_len : strlen_range;
		fill    : char)};

var
d,
len : strlen_range;
begin
len := min(src_len, dst_len);
if len <> 0 then
  move(str_object(src)[st1], str_object(dst)[st2], len);
d := st2 + len;
len := dst_len - src_len;
if len > 0 then
  fillchar(str_object(dst)[d],len,fill);
end; {ch_copy_fnm_str}

{--------------------------------------------------------------------}

procedure ch_fill {(
	var     dst  ;
		st1  : strlen_range;
		len  : strlen_range;
		fill : char)};

begin
if len > 0 then
  fillchar(str_object(dst)[st1],len,fill);
end;

procedure ch_fill_name {(
	var     dst  ;
		st1  : strlen_range;
		len  : strlen_range;
		fill : char)};

begin
if len > 0 then
  fillchar(str_object(dst)[st1],len,fill);
end; {ch_fill_name}


{--------------------------------------------------------------------}

function ch_length {(
	var     str ;
		len : strlen_range)
	: strlen_range};

begin
ch_length := 0;
{inc(len);}
while (len > 0) do
  if write_str(str)[len] <> ' ' then
    begin
    ch_length := len;
    exit;
    end
  else
    dec(len);
end;

function ch_length_name {(
	var     str ;
		len : strlen_range)
	: strlen_range};

begin
ch_length_name := 0;
{inc(len);}
while (len > 0) do
  if write_str(str)[len] <> ' ' then
    begin
    ch_length_name := len;
    exit;
    end
  else
    dec(len);
end; {ch_length_name}


{--------------------------------------------------------------------}

procedure ch_upcase_str {(
	var     str ;
		len : strlen_range)};

var
i : strlen_range;
begin
for i := 1 to len do
  str_object(str)[i] := upcase(str_object(str)[i]);
end;

procedure ch_upcase_key {(
	var     str ;
		len : strlen_range)};

var
i : strlen_range;
begin
for i := 1 to len do
  str_object(str)[i] := upcase(str_object(str)[i]);
end; {ch_upcase_key}

procedure ch_upcase_name {(
	var     str ;
		len : strlen_range)};

var
i : strlen_range;
begin
for i := 1 to len do
  str_object(str)[i] := upcase(str_object(str)[i]);
end; {ch_upcase_name}

{--------------------------------------------------------------------}

procedure ch_locase_str {(
	var     str ;
		len : strlen_range)};

var
tmp_str : string;
i : strlen_range;
begin
move(str,tmp_str[1], len);
for i := 1 to len do
  if ord(tmp_str[i]) in upper_set then
    tmp_str[i] := chr(ord(tmp_str[i])+32);
move(tmp_str[1], str, len);
end;

{--------------------------------------------------------------------}

function ch_upcase_chr {(
		ch      : char)
	: char};

begin
ch_upcase_chr := upcase(ch);
end;

{--------------------------------------------------------------------}

function ch_locase_chr {(
		ch      : char)
	: char};

begin
if ord(ch) in upper_set then
  ch_locase_chr := chr(ord(ch)+32);
end;

{--------------------------------------------------------------------}

procedure ch_reverse_str {(
	var     src : str_object;
	var     dst : str_object;
		len : strlen_range)};

{ Assumes that src and dest are not overlapping. }
var
i       : integer;
begin
for i := 1 to len do
  dst[succ(len)-i] := src[i];
end;

{--------------------------------------------------------------------}

function ch_compare_str {(
	var     target    : str_object;
		st1       : strlen_range;
		len1      : strlen_range;
	var     text      : str_object;
		st2       : strlen_range;
		len2      : strlen_range;
		exactcase : boolean;
	var     nch_ident : strlen_range)
	: integer};

var
diff,
i       : integer;
s       : str_object;
begin
move(text[st2], s[1], len2);
if not exactcase then
  ch_upcase_str(s[1], len2);    {not sure about length here was len2-st2}
while (i <= len1) and (i <= len2) and (target[i+st1] = s[i]) do
  begin
  inc(i);
  end;
nch_ident := i;
if (i <= len1) then
  diff := 1
else
  if (i <= len2) then
    diff := -1
  else
    diff := 0;
ch_compare_str := diff;
end;

{-------------------------------------------------------------------}

function ch_search_str {(
	var     target    : str_object;
		st1       : strlen_range;
		len1      : strlen_range;
	var     text      : str_object;
		st2       : strlen_range;
		len2      : strlen_range;
		exactcase : boolean;
		backwards : boolean;
	var     found_loc : strlen_range)
	: boolean};

label 99;
var
i       : integer;
s       : str_object;
begin
ch_search_str := false;
move(text[st2], s[1], len2);
if backwards then
  begin
  for i := 1 to len2 do
    s[succ(len2)-i] := text[i];
  found_loc := len2;
  end
else
  found_loc := 0;
if not exactcase then
  ch_upcase_str(s[1], len2);    {not sure about length here was len2-st2}
for i := 1 to len2 - len1 do
  begin
  if msdos_bcmp(target[st1], s[i], len1) then
    begin
    ch_search_str := true;
    if backwards then
      found_loc := succ(len2-(i+len1))
    else
      found_loc := pred(i);
    goto 99;
    end;
  end;
99 :
end;

end.
{#endif}

